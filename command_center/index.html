<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Disaster Operations Center</title>
  <script src="node_modules/chart.js/dist/chart.umd.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: #333;
        overflow-x: hidden;
      }

      .header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
  .location-filter-wrapper { display:flex; align-items:center; gap:6px; background:#ffffff; border:2px solid #e2e8f0; padding:6px 12px; border-radius:10px; }
  .location-filter-wrapper label { font-size:13px; font-weight:600; color:#334155; }
  #locationFilter { border: none; background: transparent; font-size:14px; font-weight:600; color:#1e3c72; outline:none; cursor:pointer; }
  #locationFilter option { font-weight:500; }

      .logo {
        display: flex;
        align-items: center;
        gap: 10px;  
      }

      .logo h1 {
        color: #1e3c72;
        font-size: 1.8em;
        font-weight: 600;
        margin-left: -50px;  
      }

  .status-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 20px;
        border-radius: 25px;
        background: #f0f9ff;
        border: 2px solid #0ea5e9;
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #10b981;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .main-container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 30px 20px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 25px;
      }

      .card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      }

      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #f1f5f9;
      }

      .card-title {
        font-size: 1.3em;
        font-weight: 600;
        color: #1e293b;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .card-icon {
        font-size: 1.5em;
      }

      .sensor-location {
        background: #e0f2fe;
        color: #0369a1;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: 500;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .metric {
        text-align: center;
        padding: 15px;
        background: #f8fafc;
        border-radius: 10px;
        border-left: 4px solid #3b82f6;
      }

      .metric-value {
        font-size: 1.5em;
        font-weight: 700;
        color: #1e293b;
        display: block;
      }

      .metric-label {
        font-size: 0.9em;
        color: #64748b;
        margin-top: 5px;
      }

      .chart-container {
        position: relative;
        height: 300px;
        margin-top: 20px;
      }

      .alert-card {
        border-left: 5px solid #ef4444;
        background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
      }

      .warning-card {
        border-left: 5px solid #f59e0b;
        background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
      }

      .normal-card {
        border-left: 5px solid #10b981;
        background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
      }

      .connection-section {
        grid-column: 1 / -1;
        background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        color: white;
        text-align: center;
      }

      .connection-section .card-title {
        color: white;
        justify-content: center;
      }

      .btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
        padding: 12px 30px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 10px;
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .status-message {
        margin-top: 20px;
        padding: 15px;
        border-radius: 10px;
        font-weight: 600;
        min-height: 20px;
        /* Added default styling for visibility on dark gradient background */
        background: rgba(255, 255, 255, 0.15);
        color: #f1f5f9;
        border: 1px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(4px);
      }

      /* Override colors when specific status variants are applied */
      .status-message.status-success, .status-message.status-error { color: inherit; }

      .status-success {
        background: #ecfdf5; /* lighter mint */
        color: #047857; /* darker teal for contrast */
        border: 2px solid #34d399;
        box-shadow: 0 2px 6px rgba(16,185,129,0.15);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .status-error {
        background: rgba(239, 68, 68, 0.1);
        color: #7f1d1d;
        border: 2px solid rgba(239, 68, 68, 0.3);
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .last-updated {
        text-align: center;
        color: #64748b;
        font-size: 0.9em;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #e2e8f0;
      }

      .controls {
  display: flex;
  align-items: center;
  gap: 10px;
      }

      .refresh-btn {
        background: #10b981;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .refresh-btn:hover {
        background: #059669;
        transform: translateY(-2px);
      }

  /* Header actions: notifications + controls */
  .header-actions { display: flex; align-items: center; gap: 12px; }
  .icon-btn { position: relative; background: #ffffff; border: 2px solid #e2e8f0; color: #1e293b; padding: 8px 12px; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
  .icon-btn:hover { background: #f8fafc; transform: translateY(-1px); }
  .notif-btn { width: 40px; height: 40px; display: inline-flex; align-items: center; justify-content: center; border-radius: 50%; }
  .notif-badge { position: absolute; top: -4px; right: -4px; background: #ef4444; color: #fff; font-size: 11px; min-width: 18px; height: 18px; border-radius: 9px; display: flex; align-items: center; justify-content: center; padding: 0 5px; }
  .notif-panel { position: absolute; top: 55px; right: 0; width: 360px; max-height: 420px; overflow: auto; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.12); display: none; z-index: 200; }
  .notif-header { padding: 12px 14px; border-bottom: 1px solid #e5e7eb; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
  .notif-list { padding: 8px 0; }
  .notif-item { padding: 10px 14px; display: flex; gap: 10px; align-items: flex-start; border-bottom: 1px solid #f1f5f9; }
  .notif-item:last-child { border-bottom: none; }
  .notif-type { width: 8px; height: 24px; border-radius: 4px; margin-top: 2px; }
  .notif-time { font-size: 11px; color: #64748b; }
  .status-text { font-size: 13px; color: #334155; }

  /* Modal styles */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 300; }
  .modal { width: min(1000px, 92%); background: #fff; border-radius: 14px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); overflow: hidden; }
  .modal-header { padding: 14px 18px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e7eb; }
  .modal-title { font-weight: 700; color: #111827; }
  .modal-body { padding: 16px; height: 520px; }
  .close-btn { background: transparent; border: none; font-size: 22px; cursor: pointer; }

  /* Removed user management & large alert styles */

      @media (max-width: 768px) {
        .main-container {
          grid-template-columns: 1fr;
          padding: 20px 15px;
        }
        
        .header-content {
          flex-direction: column;
          gap: 15px;
        }
        
        .metrics-grid {
          grid-template-columns: repeat(2, 1fr);
        }

        .user-grid {
          grid-template-columns: 1fr;
        }

        .user-stats {
          grid-template-columns: repeat(2, 1fr);
        }

        .activity-item {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }

        .activity-time {
          text-align: left;
          min-width: auto;
        }
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="header-content">
        <div class="logo">
          <h1>üö®Disaster Operations Center</h1>
        </div>
        <div class="header-actions">
          <div class="location-filter-wrapper" title="Filter sensors by location">
            <label for="locationFilter">Location:</label>
            <select id="locationFilter">
              <option value="All">All</option>
              <option value="Gampaha">Gampaha</option>
              <option value="Rathnapura">Rathnapura</option>
            </select>
          </div>
          <div class="location-filter-wrapper" title="Generate analytical PDF report">
            <label for="reportTypeSelect">Report:</label>
            <select id="reportTypeSelect">
              <option value="combined">Flood & Landslide</option>
              <option value="flood">Flood Only</option>
              <option value="landslide">Landslide Only</option>
            </select>
            <select id="reportRangeSelect" title="Time Range">
              <option value="6h">Last 6h</option>
              <option value="24h" selected>Last 24h</option>
              <option value="7d">Last 7d</option>
            </select>
            <button id="generateReportBtn" class="icon-btn" style="padding:6px 14px;">Export</button>
          </div>
          <div class="status-indicator">
            <div class="status-dot"></div>
            <span id="connectionStatus">All Systems Online</span>
          </div>
          <button id="refreshDataBtn" class="icon-btn" title="Refresh data">üîÑ Refresh</button>
          <button id="testConnectionBtn" class="icon-btn" title="Test Firebase connection">üß™ Test</button>
          <div style="position: relative;">
            <button id="notifButton" class="icon-btn notif-btn" title="Alerts">üîî<span id="notifBadge" class="notif-badge" style="display:none;">0</span></button>
            <div id="notifPanel" class="notif-panel">
              <div class="notif-header">
                <span>Notifications</span>
                <button id="clearAlertsBtn" class="icon-btn" style="padding:6px 10px;">Clear</button>
              </div>
              <div id="notifList" class="notif-list"></div>
            </div>
          </div>
        </div>
      </div>
    </header>

    <div class="main-container">
      <div id="statusMessage" class="status-message" style="grid-column: 1 / -1;"></div>

      <!-- BMP180 Environmental Sensor -->
  <div class="card normal-card" id="bmp180Card" data-location="Gampaha">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üå°Ô∏è</span>
            Environmental Readings (BMP180)
          </div>
          <div class="sensor-location">Gampaha</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="temperatureValue">--</span>
            <div class="metric-label">Temperature (¬∞C)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="pressureValue">--</span>
            <div class="metric-label">Pressure (hPa)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="altitudeValue">--</span>
            <div class="metric-label">Altitude (m)</div>
          </div>
        </div>
    <div class="chart-container">
          <canvas id="bmp180Chart"></canvas>
        </div>
        <div class="last-updated" id="bmp180LastUpdated">Last updated: --</div>
      </div>

      <!-- MPU6050 Seismic Sensor -->
  <div class="card normal-card" id="mpu6050Card" data-location="Rathnapura">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üìä</span>
            IMU Readings (MPU6050)
          </div>
          <div class="sensor-location">Rathnapura</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="accelXValue">--</span>
            <div class="metric-label">Accel X (g)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="accelYValue">--</span>
            <div class="metric-label">Accel Y (g)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="accelZValue">--</span>
            <div class="metric-label">Accel Z (g)</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="mpu6050Chart"></canvas>
        </div>
        <div class="last-updated" id="mpu6050LastUpdated">Last updated: --</div>
      </div>

  <!-- Rain Sensor -->
  <div class="card normal-card" id="rainCard" data-location="Rathnapura">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üåßÔ∏è</span>
            Rainfall Readings
          </div>
          <div class="sensor-location" id="rainLocation">Unknown</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="rainIntensity">--</span>
            <div class="metric-label">Rain Intensity</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="rainStatus">--</span>
            <div class="metric-label">Status</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="rainChart"></canvas>
        </div>
        <div class="last-updated" id="rainLastUpdated">Last updated: --</div>
      </div>

      <!-- Floods Rain Sensor (additional rainfall source) -->
  <div class="card normal-card" id="floodsRainCard" data-location="Gampaha">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üåßÔ∏è</span>
            Rain Readings(Floods)
          </div>
          <div class="sensor-location" id="floodsRainLocation">Unknown</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="floodsRainIntensity">--</span>
            <div class="metric-label">Rain Intensity</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="floodsRainStatus">--</span>
            <div class="metric-label">Status</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="floodsRainChart"></canvas>
        </div>
        <div class="last-updated" id="floodsRainLastUpdated">Last updated: --</div>
      </div>

      <!-- Soil Moisture Sensor -->
  <div class="card normal-card" id="soilCard" data-location="Rathnapura">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üå±</span>
            Soil Moisture Readings
          </div>
          <div class="sensor-location" id="soilLocation">Unknown</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="soilMoisture">--</span>
            <div class="metric-label">Moisture (Analog)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="soilStatus">--</span>
            <div class="metric-label">Status</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="soilChart"></canvas>
        </div>
        <div class="last-updated" id="soilLastUpdated">Last updated: --</div>
      </div>

      <!-- Tilt Sensor -->
  <div class="card normal-card" id="tiltCard" data-location="Rathnapura">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">‚öñÔ∏è</span>
            Tilt Readings
          </div>
          <div class="sensor-location">Rathnapura</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="tiltValue">--</span>
            <div class="metric-label">Tilt Status</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="tiltReadings">--</span>
            <div class="metric-label">Total Readings</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="tiltChart"></canvas>
        </div>
        <div class="last-updated" id="tiltLastUpdated">Last updated: --</div>
      </div>

      <!-- Water Level Sensor -->
  <div class="card normal-card" id="waterLevelCard" data-location="Gampaha">
        <div class="card-header">
          <div class="card-title">
            <span class="card-icon">üíß</span>
            Water Level Readings
          </div>
          <div class="sensor-location" id="waterLevelLocation">Gampaha</div>
        </div>
        <div class="metrics-grid">
          <div class="metric">
            <span class="metric-value" id="waterLevelValue">--</span>
            <div class="metric-label">Water Level (%)</div>
          </div>
          <div class="metric">
            <span class="metric-value" id="waterLevelStatus">--</span>
            <div class="metric-label">Status</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="waterLevelChart"></canvas>
        </div>
        <div class="last-updated" id="waterLevelLastUpdated">Last updated: --</div>
      </div>
    </div>

    <script>
      // Global variables
  let bmp180Chart, mpu6050Chart, tiltChart, rainChart, floodsRainChart, soilChart, waterLevelChart;
      let sensorData = {
        bmp180: {},
        mpu6050: {},
  rain: {},
  floodsRain: {},
        soil: {},
        tilt: {},
        waterLevel: {}
      };

  let alerts = [];
  let sensorLocations = { rain: '', floodsRain: '', soil: '', waterLevel: '' };
  // Persistent dismissal tracking for notifications
  const dismissedAlertKeys = new Set();
  let currentRawAlerts = [];
  const alertKey = (a) => `${a.type}|${a.message}|${a.time || ''}`;
  // Store notifications loaded from Firestore (historical)
  let storedNotifications = [];
  let lastPersistedKeys = new Set();
  // Persistent in-session history of all risk notifications (landslide/flood)
  const riskHistory = []; // {type,message,time,firstSeen:Date.now()}
  const riskKey = (a) => `${a.type}|${a.message}|${a.time}`;
  // Risk evaluation thresholds (tunable)
  const RISK_THRESHOLDS = {
    bmp: { lowPressure: 995, highTemp: 34 },
    rain: { heavy: 1500 }, // hillside rainfall intensity for landslide risk
    floodsRain: { heavy: 1400 }, // flood zone rainfall intensity
    waterLevel: { high: 80, critical: 95 },
  };
  // Throttle map to avoid duplicate alerts spam (per key)
  const alertLastSent = {}; // key -> timestamp ms
  const ALERT_COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes

  function renderNotificationHistory() {
    // Exclude dismissed
    const visible = riskHistory.filter(a => !dismissedAlertKeys.has(riskKey(a)));
    if (visible.length === 0) {
      notifBadge.style.display = 'none';
      notifList.innerHTML = '<div style="padding:14px; color:#64748b;">No notifications</div>';
      return;
    }
    notifBadge.style.display = 'flex';
    notifBadge.textContent = visible.length;
    // Show newest first
    const ordered = [...visible].sort((a,b)=>b.firstSeen - a.firstSeen).slice(0,100);
    notifList.innerHTML = ordered.map(a => `
      <div class="notif-item">
        <div class="notif-type" style="background:${a.type === 'landslide' ? '#f59e0b' : '#0ea5e9'}"></div>
        <div>
          <div style="font-weight:600; color:#0f172a;">${a.message}</div>
          <div class="notif-time">${a.time || 'Unknown time'}</div>
        </div>
      </div>`).join('');
  }

      // DOM elements
  const testBtn = document.getElementById('testConnectionBtn');
  const refreshBtn = document.getElementById('refreshDataBtn');
      const statusDiv = document.getElementById('statusMessage');
      const connectionStatus = document.getElementById('connectionStatus');
  const locationFilter = document.getElementById('locationFilter');
  const notifBtn = document.getElementById('notifButton');
  const notifBadge = document.getElementById('notifBadge');
  const notifPanel = document.getElementById('notifPanel');
  const notifList = document.getElementById('notifList');
  const clearAlertsBtn = document.getElementById('clearAlertsBtn');
  const generateReportBtn = document.getElementById('generateReportBtn');
  const reportTypeSelect = document.getElementById('reportTypeSelect');
  const reportRangeSelect = document.getElementById('reportRangeSelect');

      // Initialize charts
  function initializeCharts() {
        // BMP180 Chart
        const bmp180Ctx = document.getElementById('bmp180Chart').getContext('2d');
        bmp180Chart = new Chart(bmp180Ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Temperature (¬∞C)',
                data: [],
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                yAxisID: 'y'
              },
              {
                label: 'Pressure (hPa)',
                data: [],
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                yAxisID: 'y1'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: true, text: 'Temperature (¬∞C)' }
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                title: { display: true, text: 'Pressure (hPa)' },
                grid: { drawOnChartArea: false }
              }
            },
            plugins: {
              legend: { display: true },
              title: { display: true, text: 'Environmental Data Trends' }
            }
          }
        });

  // MPU6050 Chart
        const mpu6050Ctx = document.getElementById('mpu6050Chart').getContext('2d');
        mpu6050Chart = new Chart(mpu6050Ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Accel X',
                data: [],
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)'
              },
              {
                label: 'Accel Y',
                data: [],
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)'
              },
              {
                label: 'Accel Z',
                data: [],
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: { display: true, text: 'Acceleration (g)' }
              }
            },
            plugins: {
              legend: { display: true },
              title: { display: true, text: 'Seismic Activity Monitoring' }
            }
          }
        });

        // Rain Chart (plots raw analog value from rain sensor)
        const rainCtx = document.getElementById('rainChart').getContext('2d');
        rainChart = new Chart(rainCtx, {
          type: 'line',
          data: { labels: [], datasets: [{ label: 'Rain Analog', data: [], borderColor: '#06b6d4', backgroundColor: 'rgba(6, 182, 212, 0.12)', fill: true }] },
          options: { responsive: true, maintainAspectRatio: false, scales: { y: { title: { display: true, text: 'Analog Value' } } }, plugins: { legend: { display: true }, title: { display: true, text: 'Rainfall (Analog) Trends' } } }
        });

        // Floods Rain Chart
        const floodsRainCtx = document.getElementById('floodsRainChart').getContext('2d');
        floodsRainChart = new Chart(floodsRainCtx, {
          type: 'line',
          data: { labels: [], datasets: [{ label: 'Floods Rain Analog', data: [], borderColor: '#0e7490', backgroundColor: 'rgba(14, 116, 144, 0.12)', fill: true }] },
          options: { responsive: true, maintainAspectRatio: false, scales: { y: { title: { display: true, text: 'Analog Value' } } }, plugins: { legend: { display: true }, title: { display: true, text: 'Floods Rain (Analog) Trends' } } }
        });

        // Soil Moisture Chart (raw analog values)
        const soilCtx = document.getElementById('soilChart').getContext('2d');
        console.log("Initializing soil chart");
        soilChart = new Chart(soilCtx, {
          type: 'line',
          data: { 
            labels: [], 
            datasets: [{ 
              label: 'Analog', 
              data: [], 
              borderColor: '#22c55e', 
              backgroundColor: 'rgba(34, 197, 94, 0.12)', 
              fill: true 
            }] 
          },
          options: { 
            responsive: true, 
            maintainAspectRatio: false, 
            scales: { 
              y: { 
                min: 0, 
                max: 4095, 
                title: { 
                  display: true, 
                  text: 'Analog Value (0‚Äì4095)' 
                } 
              } 
            }, 
            plugins: { 
              legend: { display: true }, 
              title: { display: true, text: 'Soil Moisture (Analog) Trends' } 
            } 
          }
        });

        // Tilt Chart
        const tiltCtx = document.getElementById('tiltChart').getContext('2d');
        tiltChart = new Chart(tiltCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Tilt Status',
                data: [],
                borderColor: '#f59e0b',
                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                stepped: true,
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                min: 0,
                max: 1,
                ticks: {
                  stepSize: 1,
                  callback: function(value) {
                    // 0 = Tilted, 1 = Normal
                    return value === 0 ? 'Tilted' : 'Normal';
                  }
                },
                title: { display: true, text: 'Tilt Status' }
              }
            },
            plugins: {
              legend: { display: true },
              title: { display: true, text: 'Landslide Detection Status' }
            }
          }
        });

        // Water Level Chart
        const waterLevelCtx = document.getElementById('waterLevelChart').getContext('2d');
        waterLevelChart = new Chart(waterLevelCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Water Level (%)',
                data: [],
                borderColor: '#0ea5e9',
                backgroundColor: 'rgba(14, 165, 233, 0.1)',
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                min: 0,
                max: 100,
                title: { display: true, text: 'Water Level (%)' }
              }
            },
            plugins: {
              legend: { display: true },
              title: { display: true, text: 'Water Level Trends' }
            }
          }
        });
      }

      // Helpers to normalize sensor values
      function getSoilAnalogValue(rec) {
        if (!rec || typeof rec !== 'object') return 0;
        if (typeof rec.analog === 'number') return rec.analog;
        if (typeof rec.analog === 'string' && rec.analog.trim() !== '' && !isNaN(Number(rec.analog))) return Number(rec.analog);
        return 0;
      }

      // Process water level data
      function getWaterLevelValue(rec) {
        if (!rec || typeof rec !== 'object') return 0;
        const toNum = (v) => (typeof v === 'number' ? v : (typeof v === 'string' && v.trim() !== '' && !Number.isNaN(Number(v)) ? Number(v) : null));
        
        // Try different property names for water level
        const candidates = [
          rec.WaterLevelPercentage,
          rec.waterLevelPercentage,
          rec.waterLevel,
          rec.water_level,
          rec.level,
          rec.levelPercentage,
          rec.value
        ];
        
        let v = candidates.find(x => typeof x === 'number');
        
        // Try to parse string values
        if (v === undefined && typeof rec.value === 'string') {
          const n = Number(rec.value);
          if (!Number.isNaN(n)) v = n;
        }
        
        v = typeof v === 'number' ? v : 0;
        if (v < 0) v = 0; if (v > 100) v = 100;
        return v;
      }

      // Get water level status based on percentage
      function getWaterLevelStatus(percentage) {
        if (percentage >= 80) return 'High';
        if (percentage >= 50) return 'Medium';
        return 'Low';
      }

      // Determine soil condition/category from analog or moisture percent
      // Soil condition now derived from digital flag only: 0 = Wet, 1 = Dry
      function getSoilStatusFromDigital(rec) {
        if (!rec) return { text: '--', isDry: false };
        const d = (typeof rec.digital === 'number') ? rec.digital : Number(rec.digital);
        if (d === 0) return { text: 'Wet', isDry: false };
        if (d === 1) return { text: 'Dry', isDry: true };
        return { text: '--', isDry: false };
      }

      function getRainIntensity(rec) { // repurposed: returns raw analog value
        if (!rec || typeof rec !== 'object') return 0;
        let analog = null;
        if (typeof rec.analog === 'number') analog = rec.analog;
        else if (typeof rec.analog === 'string' && rec.analog.trim() !== '' && !isNaN(Number(rec.analog))) analog = Number(rec.analog);
        return analog !== null ? analog : 0;
      }

      // Try to extract a human-readable location string from a reading
      function getLocationString(rec) {
        if (!rec || typeof rec !== 'object') return '';
        // Common flat string fields
        const flat = [
          rec.location,
          rec.Location,
          rec.loc,
          rec.place,
          rec.site,
          rec.area,
          rec.city,
          rec.district,
          rec.region,
          rec.town
        ];
        const flatStr = flat.find(v => typeof v === 'string' && v.trim());
        if (flatStr) return flatStr.trim();

        // Nested location object
        const locObj = typeof rec.location === 'object' && rec.location !== null ? rec.location : null;
        if (locObj) {
          const { name, city, district, area, region, town } = locObj;
          const parts = [name, city, district, area, region, town].filter(s => typeof s === 'string' && s.trim());
          if (parts.length) return parts.join(', ');
        }

        // Coordinates fallback (flat)
        const latKeys = ['latitude','lat'];
        const lonKeys = ['longitude','lng','long'];
        const numOrNumStr = (v) => (typeof v === 'number' ? v : (typeof v === 'string' && !isNaN(Number(v)) ? Number(v) : null));
        for (const la of latKeys) {
          for (const lo of lonKeys) {
            const lat = numOrNumStr(rec[la]);
            const lon = numOrNumStr(rec[lo]);
            if (lat !== null && lon !== null) return `${lat}, ${lon}`;
          }
        }

        // Coordinates fallback (nested: gps/GPS/coordinates/coords)
        const nestedKeys = ['gps','GPS','coordinates','coords'];
        for (const k of nestedKeys) {
          const obj = rec[k];
          if (obj && typeof obj === 'object') {
            for (const la of latKeys) {
              for (const lo of lonKeys) {
                const lat = numOrNumStr(obj[la]);
                const lon = numOrNumStr(obj[lo]);
                if (lat !== null && lon !== null) return `${lat}, ${lon}`;
              }
            }
          }
        }
        return '';
      }

      // Helper: pick latest record from a map by timestamp property or by key if numeric-like
      function getLatestFromMap(mapObj) {
        if (!mapObj || typeof mapObj !== 'object') return null;
        const entries = Object.entries(mapObj);
        if (entries.length === 0) return null;
        // Prefer timestamp parsing
        const withTs = entries
          .map(([k, v]) => {
            let t = 0;
            if (v && typeof v === 'object' && v.timestamp) {
              const d = new Date(v.timestamp);
              if (!isNaN(d.getTime())) t = d.getTime();
            }
            return { k, v, t };
          });
        const anyTs = withTs.some(e => e.t > 0);
        if (anyTs) {
          withTs.sort((a, b) => a.t - b.t);
          return withTs[withTs.length - 1].v;
        }
        // Fallback: sort by numeric-like key
        const parsed = entries.map(([k, v]) => {
          const n = Number(k);
          return { k, v, n: Number.isFinite(n) ? n : null };
        });
        const numericOnly = parsed.filter(e => e.n !== null);
        if (numericOnly.length > 0) {
          numericOnly.sort((a, b) => a.n - b.n);
          return numericOnly[numericOnly.length - 1].v;
        }
        // Last entry fallback
        return entries[entries.length - 1][1];
      }

  // Removed user management functions

      // Update chart data
  function updateCharts() {
        // Update BMP180 chart
        if (sensorData.bmp180 && Object.keys(sensorData.bmp180).length > 0) {
          const bmpEntries = Object.entries(sensorData.bmp180)
            .filter(([key, value]) => value.temperature_C && value.pressure_hPa)
            .slice(-20);
          
          const bmpLabels = bmpEntries.map(([key, value]) => {
            const time = value.timestamp ? value.timestamp.split(' ')[1] : new Date().toLocaleTimeString();
            return time.substring(0, 5);
          });
          
          const tempData = bmpEntries.map(([key, value]) => value.temperature_C);
          const pressureData = bmpEntries.map(([key, value]) => value.pressure_hPa);
          
          bmp180Chart.data.labels = bmpLabels;
          bmp180Chart.data.datasets[0].data = tempData;
          bmp180Chart.data.datasets[1].data = pressureData;
          bmp180Chart.update();
        }

        // Update MPU6050 chart
        if (sensorData.mpu6050 && Object.keys(sensorData.mpu6050).length > 0) {
          const mpuEntries = Object.entries(sensorData.mpu6050)
            .filter(([key, value]) => value.accelX !== undefined)
            .slice(-20);
          
          const mpuLabels = mpuEntries.map(([key, value]) => {
            const time = value.timestamp ? value.timestamp.split(' ')[1] : new Date().toLocaleTimeString();
            return time.substring(0, 5);
          });
          
          const accelXData = mpuEntries.map(([key, value]) => value.accelX || 0);
          const accelYData = mpuEntries.map(([key, value]) => value.accelY || 0);
          const accelZData = mpuEntries.map(([key, value]) => value.accelZ || 0);
          
          mpu6050Chart.data.labels = mpuLabels;
          mpu6050Chart.data.datasets[0].data = accelXData;
          mpu6050Chart.data.datasets[1].data = accelYData;
          mpu6050Chart.data.datasets[2].data = accelZData;
          mpu6050Chart.update();
        }

        // Update Rain chart (analog values)
        if (sensorData.rain && Object.keys(sensorData.rain).length > 0) {
          const entries = Object.entries(sensorData.rain).slice(-20);
          const labels = entries.map(([_, v]) => (v.timestamp ? v.timestamp.split(' ')[1].substring(0,5) : new Date().toLocaleTimeString().substring(0,5)));
          const data = entries.map(([_, v]) => getRainIntensity(v));
          rainChart.data.labels = labels;
          rainChart.data.datasets[0].data = data;
          rainChart.update();
        }

        // Update Floods Rain chart (analog values)
        if (sensorData.floodsRain && Object.keys(sensorData.floodsRain).length > 0) {
          const entries = Object.entries(sensorData.floodsRain).slice(-20);
          const labels = entries.map(([_, v]) => (v.timestamp ? v.timestamp.split(' ')[1].substring(0,5) : new Date().toLocaleTimeString().substring(0,5)));
          const data = entries.map(([_, v]) => getRainIntensity(v));
          floodsRainChart.data.labels = labels;
          floodsRainChart.data.datasets[0].data = data;
          floodsRainChart.update();
        }

  // Update Soil chart (analog values)
        if (sensorData.soil && Object.keys(sensorData.soil).length > 0) {
          console.log("Soil data found:", JSON.stringify(sensorData.soil).substring(0, 200) + "...");
          
          // Try to extract entries in the expected format
          let entries = Object.entries(sensorData.soil).slice(-20);
          console.log("Soil entries count:", entries.length);
          
          // If we don't have valid entries, try to create a synthetic entry for display
          if (entries.length === 0) {
            console.log("Creating synthetic soil entry");
            // Create a synthetic entry if soil data exists but not in expected format
            const timestamp = new Date().toLocaleTimeString();
            entries = [['1', { ...sensorData.soil, timestamp }]];
          }
          
          const labels = entries.map(([_, v]) => (v.timestamp ? v.timestamp.split(' ')[1].substring(0,5) : new Date().toLocaleTimeString().substring(0,5)));
          const data = entries.map(([_, v]) => {
            const value = getSoilAnalogValue(v);
            console.log("Soil analog value:", value, "from entry:", JSON.stringify(v).substring(0, 100) + "...");
            return value;
          });
          
          console.log("Soil chart data:", data);
          console.log("Soil chart labels:", labels);
          
          soilChart.data.labels = labels;
          soilChart.data.datasets[0].data = data;
          soilChart.update();
        } else {
          console.log("No soil data available. sensorData.soil exists:", !!sensorData.soil, 
                     "Length:", sensorData.soil ? Object.keys(sensorData.soil).length : 0);
        }

        // Update Tilt chart
        if (sensorData.tilt && Object.keys(sensorData.tilt).length > 0) {
          const tiltEntries = Object.entries(sensorData.tilt)
            .filter(([key, value]) => value.value !== undefined)
            .slice(-20);
          
          const tiltLabels = tiltEntries.map(([key, value]) => {
            const time = value.timestamp ? value.timestamp.split(' ')[1] : new Date().toLocaleTimeString();
            return time.substring(0, 5);
          });
          
          const tiltData = tiltEntries.map(([key, value]) => value.value);
          
          tiltChart.data.labels = tiltLabels;
          tiltChart.data.datasets[0].data = tiltData;
          tiltChart.update();
        }

        // Update Water Level chart
        if (sensorData.waterLevel && Object.keys(sensorData.waterLevel).length > 0) {
          console.log("Water level data found:", JSON.stringify(sensorData.waterLevel).substring(0, 200) + "...");
          
          // Try to extract entries in the expected format
          let entries = Object.entries(sensorData.waterLevel).slice(-20);
          console.log("Water level entries count:", entries.length);
          
          // If we don't have valid entries, try to create a synthetic entry for display
          if (entries.length === 0) {
            console.log("Creating synthetic water level entry");
            // Create a synthetic entry if water level data exists but not in expected format
            const timestamp = new Date().toLocaleTimeString();
            entries = [['1', { ...sensorData.waterLevel, timestamp }]];
          }
          
          const labels = entries.map(([_, v]) => (v.time || v.timestamp) ? 
            (v.time || v.timestamp).split(' ')[1].substring(0,5) : 
            new Date().toLocaleTimeString().substring(0,5));
          
          const data = entries.map(([_, v]) => {
            const value = getWaterLevelValue(v);
            console.log("Water level value calculated:", value, "from entry:", JSON.stringify(v).substring(0, 100) + "...");
            return value;
          });
          
          console.log("Water level chart data:", data);
          console.log("Water level chart labels:", labels);
          
          waterLevelChart.data.labels = labels;
          waterLevelChart.data.datasets[0].data = data;
          waterLevelChart.update();
        } else {
          console.log("No water level data available. sensorData.waterLevel exists:", !!sensorData.waterLevel, 
                     "Length:", sensorData.waterLevel ? Object.keys(sensorData.waterLevel).length : 0);
        }
      }

      // Update sensor displays
  function updateSensorDisplays() {
        // Update BMP180 displays
        if (sensorData.bmp180 && Object.keys(sensorData.bmp180).length > 0) {
          const latestBmp = Object.values(sensorData.bmp180).slice(-1)[0];
          if (latestBmp) {
            document.getElementById('temperatureValue').textContent = 
              latestBmp.temperature_C ? latestBmp.temperature_C.toFixed(1) : '--';
            document.getElementById('pressureValue').textContent = 
              latestBmp.pressure_hPa ? latestBmp.pressure_hPa.toFixed(1) : '--';
            document.getElementById('altitudeValue').textContent = 
              latestBmp.altitude_m ? latestBmp.altitude_m.toFixed(1) : '--';
            document.getElementById('bmp180LastUpdated').textContent = 
              `Last updated: ${latestBmp.timestamp || 'Unknown'}`;
            
            // Update card status
            const bmp180Card = document.getElementById('bmp180Card');
            if (latestBmp.temperature_C > 35 || latestBmp.pressure_hPa < 1000) {
              bmp180Card.className = 'card warning-card';
            } else {
              bmp180Card.className = 'card normal-card';
            }
          }
  }

  // Update MPU6050 displays
        if (sensorData.mpu6050 && Object.keys(sensorData.mpu6050).length > 0) {
          const latestMpu = Object.values(sensorData.mpu6050).slice(-1)[0];
          if (latestMpu) {
            document.getElementById('accelXValue').textContent = 
              latestMpu.accelX !== undefined ? latestMpu.accelX.toFixed(3) : '--';
            document.getElementById('accelYValue').textContent = 
              latestMpu.accelY !== undefined ? latestMpu.accelY.toFixed(3) : '--';
            document.getElementById('accelZValue').textContent = 
              latestMpu.accelZ !== undefined ? latestMpu.accelZ.toFixed(3) : '--';
            document.getElementById('mpu6050LastUpdated').textContent = 
              `Last updated: ${latestMpu.timestamp || 'Unknown'}`;
            
            // Check for high acceleration (potential earthquake)
            const mpu6050Card = document.getElementById('mpu6050Card');
            const totalAccel = Math.sqrt(
              (latestMpu.accelX || 0) ** 2 + 
              (latestMpu.accelY || 0) ** 2 + 
              (latestMpu.accelZ || 0) ** 2
            );
            
            if (totalAccel > 1.5) {
              mpu6050Card.className = 'card alert-card';
            } else if (totalAccel > 1.2) {
              mpu6050Card.className = 'card warning-card';
            } else {
              mpu6050Card.className = 'card normal-card';
            }
          }
        }

        // Update Rain displays (digital: 0=Rain Detected, 1=No Rain)
        if (sensorData.rain && Object.keys(sensorData.rain).length > 0) {
          const latest = getLatestFromMap(sensorData.rain);
          if (latest) {
            const intensity = getRainIntensity(latest);
            const digital = (typeof latest.digital === 'number') ? latest.digital : Number(latest.digital);
            const isRaining = digital === 0; // 0 = rain detected
            document.getElementById('rainIntensity').textContent = (typeof intensity === 'number' && intensity.toFixed) ? intensity.toFixed(0) : intensity;
            document.getElementById('rainStatus').textContent = isRaining ? 'Rain Detected' : 'No Rain';
            document.getElementById('rainLastUpdated').textContent = `Last updated: ${latest.timestamp || 'Unknown'}`;
            const card = document.getElementById('rainCard');
            card.className = isRaining ? 'card warning-card' : 'card normal-card';
            const rainLoc = getLocationString(latest) || sensorLocations.rain;
            const chip = document.getElementById('rainLocation');
            if (chip) chip.textContent = rainLoc || 'Unknown';
          }
        }

        // Update Floods Rain displays (digital: 0=Rain Detected, 1=No Rain)
        if (sensorData.floodsRain && Object.keys(sensorData.floodsRain).length > 0) {
          const latest = getLatestFromMap(sensorData.floodsRain);
          if (latest) {
            const intensity = getRainIntensity(latest);
            const digital = (typeof latest.digital === 'number') ? latest.digital : Number(latest.digital);
            const isRaining = digital === 0; // 0 = rain detected
            document.getElementById('floodsRainIntensity').textContent = (typeof intensity === 'number' && intensity.toFixed) ? intensity.toFixed(0) : intensity;
            document.getElementById('floodsRainStatus').textContent = isRaining ? 'Rain Detected' : 'No Rain';
            document.getElementById('floodsRainLastUpdated').textContent = `Last updated: ${latest.timestamp || 'Unknown'}`;
            const card = document.getElementById('floodsRainCard');
            card.className = isRaining ? 'card warning-card' : 'card normal-card';
            const frLoc = getLocationString(latest) || sensorLocations.floodsRain || sensorLocations.rain;
            const chip = document.getElementById('floodsRainLocation');
            if (chip) chip.textContent = frLoc || 'Unknown';
          }
        }

        // Update Soil displays (analog + digital status)
        if (sensorData.soil && Object.keys(sensorData.soil).length > 0) {
          const latest = getLatestFromMap(sensorData.soil);
          if (latest) {
            const analog = getSoilAnalogValue(latest);
            const status = getSoilStatusFromDigital(latest);
            document.getElementById('soilMoisture').textContent = analog;
            document.getElementById('soilStatus').textContent = status.text;
            document.getElementById('soilLastUpdated').textContent = `Last updated: ${latest.timestamp || 'Unknown'}`;
            const card = document.getElementById('soilCard');
            card.className = status.isDry ? 'card warning-card' : 'card normal-card';
            const soilLoc = getLocationString(latest) || sensorLocations.soil;
            const chip = document.getElementById('soilLocation');
            if (chip) chip.textContent = soilLoc || 'Unknown';
          }
        }

        // Update Tilt displays
        if (sensorData.tilt && Object.keys(sensorData.tilt).length > 0) {
          const latestTilt = Object.values(sensorData.tilt).slice(-1)[0];
          const totalReadings = Object.keys(sensorData.tilt).length;
          
          if (latestTilt) {
            document.getElementById('tiltValue').textContent = 
              latestTilt.value === 0 ? 'TILTED' : 'NORMAL';
            document.getElementById('tiltReadings').textContent = totalReadings;
            document.getElementById('tiltLastUpdated').textContent = 
              `Last updated: ${latestTilt.timestamp || 'Unknown'}`;
            
            // Update card status
            const tiltCard = document.getElementById('tiltCard');
            if (latestTilt.value === 0) { // 0 = tilted
              tiltCard.className = 'card alert-card';
            } else {
              tiltCard.className = 'card normal-card';
            }
          }
        }

        // Update Water Level displays
        if (sensorData.waterLevel && Object.keys(sensorData.waterLevel).length > 0) {
          const latest = getLatestFromMap(sensorData.waterLevel);
          
          if (latest) {
            const waterLevel = getWaterLevelValue(latest);
            const status = getWaterLevelStatus(waterLevel);
            
            document.getElementById('waterLevelValue').textContent = 
              typeof waterLevel === 'number' && waterLevel.toFixed ? waterLevel.toFixed(1) : waterLevel;
            document.getElementById('waterLevelStatus').textContent = status;
            document.getElementById('waterLevelLastUpdated').textContent = 
              `Last updated: ${latest.time || latest.timestamp || 'Unknown'}`;
            
            // Update card status
            const waterLevelCard = document.getElementById('waterLevelCard');
            if (status === 'High') {
              waterLevelCard.className = 'card alert-card';
            } else if (status === 'Medium') {
              waterLevelCard.className = 'card warning-card';
            } else {
              waterLevelCard.className = 'card normal-card';
            }
            
            // Update location
            const waterLevelLoc = getLocationString(latest) || sensorLocations.waterLevel;
            const chip = document.getElementById('waterLevelLocation');
            if (chip) chip.textContent = waterLevelLoc || 'Unknown';
          }
        }
      }

      // Check for alerts
      function checkAlerts() {
  alerts = [];
  currentRawAlerts = [];

        // --- Per-sensor evaluators (7 sensors) ---
        // Helper to add risk alert with cooldown
        const addRisk = (type, message, baseTime, keyExtra='') => {
          const key = `${type}|${message}|${keyExtra}`;
          const now = Date.now();
          const last = alertLastSent[key] || 0;
          if (now - last < ALERT_COOLDOWN_MS) return; // skip duplicate within cooldown
          alertLastSent[key] = now;
          alerts.push({ type, message, time: baseTime });
        };

        const evalBmp180 = () => {
          if (!sensorData.bmp180 || Object.keys(sensorData.bmp180).length === 0) return;
          const latest = Object.values(sensorData.bmp180).slice(-1)[0];
          if (!latest) return;
          const t = latest.temperature_C;
          const p = latest.pressure_hPa;
          if (p !== undefined && p <= RISK_THRESHOLDS.bmp.lowPressure) {
            addRisk('flood', `Low atmospheric pressure ${p.toFixed(1)} hPa (possible heavy rain system)`, latest.timestamp, 'pressure');
          }
          if (t !== undefined && t >= RISK_THRESHOLDS.bmp.highTemp && p <= RISK_THRESHOLDS.bmp.lowPressure) {
            addRisk('flood', `Warm & low-pressure air mass (T=${t.toFixed(1)}¬∞C, P=${p.toFixed(1)} hPa)`, latest.timestamp, 'tempPressureCombo');
          }
        };

        const evalMpu6050 = () => {
          if (!sensorData.mpu6050 || Object.keys(sensorData.mpu6050).length === 0) return;
          const latest = Object.values(sensorData.mpu6050).slice(-1)[0];
          if (!latest) return;
          const total = Math.sqrt((latest.accelX||0)**2 + (latest.accelY||0)**2 + (latest.accelZ||0)**2);
          if (total > 1.5) alerts.push({ type: 'landslide', message: `High ground vibration detected (${total.toFixed(3)}g)`, time: latest.timestamp });
          else if (total > 1.2) alerts.push({ type: 'landslide', message: `Elevated ground vibration (${total.toFixed(3)}g)`, time: latest.timestamp });
        };

        const evalRain = () => {
          if (!sensorData.rain || Object.keys(sensorData.rain).length === 0) return;
          const latest = Object.values(sensorData.rain).slice(-1)[0];
          if (!latest) return;
          const analog = getRainIntensity(latest);
          const digital = (typeof latest.digital === 'number') ? latest.digital : Number(latest.digital);
          const raining = digital === 0; // 0 = rain detected
          if (raining && analog >= RISK_THRESHOLDS.rain.heavy) {
            addRisk('landslide', `Sustained heavy rainfall (${analog}) - slope saturation risk`, latest.timestamp, 'rain');
          }
        };

        const evalFloodsRain = () => {
          if (!sensorData.floodsRain || Object.keys(sensorData.floodsRain).length === 0) return;
          const latest = Object.values(sensorData.floodsRain).slice(-1)[0];
          if (!latest) return;
          const analog = getRainIntensity(latest);
          const digital = (typeof latest.digital === 'number') ? latest.digital : Number(latest.digital);
          const raining = digital === 0;
          if (raining && analog >= RISK_THRESHOLDS.floodsRain.heavy) {
            addRisk('flood', `Heavy rainfall in flood zone (${analog})`, latest.timestamp, 'floodsRain');
          }
        };

        const evalSoil = () => {
          if (!sensorData.soil || Object.keys(sensorData.soil).length === 0) return;
          const latest = Object.values(sensorData.soil).slice(-1)[0];
          if (!latest) return;
          const analog = getSoilAnalogValue(latest);
          const digitalStatus = getSoilStatusFromDigital(latest); // digital 1 => Dry
          if (digitalStatus.isDry && analog > 2500) addRisk('landslide', `Soil dryness detected (analog ${analog})`, latest.timestamp, 'soilDry');
          if (analog < 800) addRisk('landslide', `Soil saturation detected (analog ${analog})`, latest.timestamp, 'soilWet');
        };

        const evalTilt = () => {
          if (!sensorData.tilt || Object.keys(sensorData.tilt).length === 0) return;
          const latest = Object.values(sensorData.tilt).slice(-1)[0];
          if (!latest) return;
          if (latest.value === 0) addRisk('landslide', 'Slope tilt detected (possible movement)', latest.timestamp, 'tilt');
        };

        const evalWaterLevel = () => {
          if (!sensorData.waterLevel || Object.keys(sensorData.waterLevel).length === 0) return;
          const latest = getLatestFromMap(sensorData.waterLevel);
          if (!latest) return;
          const val = getWaterLevelValue(latest);
          if (val >= RISK_THRESHOLDS.waterLevel.critical) addRisk('flood', `Critical water level ${val.toFixed(1)}%`, latest.timestamp || latest.time, 'waterCritical');
          else if (val >= RISK_THRESHOLDS.waterLevel.high) addRisk('flood', `High water level ${val.toFixed(1)}%`, latest.timestamp || latest.time, 'waterHigh');
        };

        // Execute evaluators
        evalBmp180();
        evalMpu6050();
        evalRain();
        evalFloodsRain();
        evalSoil();
        evalTilt();
        evalWaterLevel();

        // Preserve raw alerts for potential dismissal
        currentRawAlerts = [...alerts];
        // Filter out any previously dismissed alerts
        alerts = alerts.filter(a => !dismissedAlertKeys.has(alertKey(a)));

        if (alerts.length > 0) {
          // Persist any NEW alerts to Firestore (avoid duplicates by key)
          // Only persist landslide / flood alerts (risk events)
          const riskAlerts = alerts.filter(a => a.type === 'landslide' || a.type === 'flood');
          const newToPersist = riskAlerts.filter(a => {
            const k = alertKey(a);
            return !lastPersistedKeys.has(k);
          }).map(a => ({ ...a, key: alertKey(a), timeISO: new Date().toISOString() }));
          if (newToPersist.length > 0 && window.electronAPI && window.electronAPI.saveNotifications) {
            window.electronAPI.saveNotifications(newToPersist).then(res => {
              if (res && res.success) {
                newToPersist.forEach(n => lastPersistedKeys.add(n.key));
              }
            }).catch(()=>{});
          }
          // Merge into history (dedupe by type+message+time)
          for (const a of riskAlerts) {
            const k = riskKey(a);
            if (!riskHistory.find(r => riskKey(r) === k)) {
              riskHistory.push({ ...a, firstSeen: Date.now() });
            }
          }
          renderNotificationHistory();
        } else {
          // No new alerts; still render existing history
          renderNotificationHistory();
        }
      }

      // Load existing notifications from Firestore on startup
      async function loadStoredNotifications() {
        if (!window.electronAPI || !window.electronAPI.getNotifications) return;
        try {
          const res = await window.electronAPI.getNotifications();
          if (res.success) {
            storedNotifications = res.data || [];
            // Seed lastPersistedKeys so we don't duplicate existing ones
            storedNotifications.forEach(n => {
              const k = riskKey(n);
              lastPersistedKeys.add(`${n.type}|${n.message}|${n.time}`);
              if (!riskHistory.find(r => riskKey(r) === k)) {
                riskHistory.push({ type: n.type, message: n.message, time: n.time, firstSeen: Date.now() });
              }
            });
            renderNotificationHistory();
          }
        } catch (e) {
          console.warn('Failed to load stored notifications', e.message);
        }
      }

      // Test Firebase connection
      async function testConnection() {
        testBtn.disabled = true;
        testBtn.innerHTML = '<span class="loading"></span>Testing Connection...';
        
        statusDiv.className = 'status-message';
        statusDiv.textContent = '';

        try {
          const result = await window.electronAPI.testFirebaseConnection();
          
          if (result.success) {
            statusDiv.className = 'status-message status-success';
            statusDiv.textContent = '‚úÖ ' + result.message;
            connectionStatus.textContent = 'Connected';
          } else {
            statusDiv.className = 'status-message status-error';
            statusDiv.textContent = '‚ùå ' + result.message;
            connectionStatus.textContent = 'Disconnected';
          }
        } catch (error) {
          statusDiv.className = 'status-message status-error';
          statusDiv.textContent = '‚ùå Connection test failed: ' + error.message;
          connectionStatus.textContent = 'Error';
        }

        testBtn.disabled = false;
        testBtn.textContent = 'Test Connection';
      }

      // Fetch and update sensor data
      async function refreshData(silent = false) {
        if (!silent) {
          refreshBtn.disabled = true;
          refreshBtn.textContent = 'Loading...';
        }
        
        try {
          const result = await window.electronAPI.fetchLatestSensorData();
          
          if (result.success) {
            console.log("Data refresh success. Debug info:", result.data.debug || {});
            console.log("Soil data exists:", !!result.data.soil);
            console.log("Soil data keys:", Object.keys(result.data.soil || {}).length);
            
            sensorData = result.data;
            if (result.data && result.data.locations) {
              sensorLocations = { ...sensorLocations, ...result.data.locations };
            }
            updateSensorDisplays();
            updateCharts();
            checkAlerts();
            
            if (!silent) {
              statusDiv.className = 'status-message status-success';
              statusDiv.textContent = '‚úÖ Data refreshed successfully';
            }
          } else {
            if (!silent) {
              statusDiv.className = 'status-message status-error';
              statusDiv.textContent = '‚ùå Failed to fetch data: ' + result.message;
            }
          }
        } catch (error) {
          if (!silent) {
            statusDiv.className = 'status-message status-error';
            statusDiv.textContent = '‚ùå Data fetch failed: ' + error.message;
          }
        }
        
        if (!silent) {
          refreshBtn.disabled = false;
          refreshBtn.textContent = 'üîÑ Refresh';
        }
      }

      // Event listeners
      testBtn.addEventListener('click', testConnection);
  refreshBtn.addEventListener('click', () => refreshData(false));
      // Location filter logic
      function applyLocationFilter() {
        const selected = locationFilter.value;
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => {
          const loc = card.getAttribute('data-location');
          if (!loc) return; // skip non-sensor cards if any in future
          if (selected === 'All' || loc === selected) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        });
      }
      locationFilter.addEventListener('change', applyLocationFilter);
      generateReportBtn.addEventListener('click', async () => {
        if (!window.electronAPI || !window.electronAPI.generateReport) {
          alert('Report generation not available in this build');
          return;
        }
        generateReportBtn.disabled = true;
        const original = generateReportBtn.textContent;
        generateReportBtn.textContent = 'Generating...';
        try {
          const res = await window.electronAPI.generateReport({ reportType: reportTypeSelect.value, timeRange: reportRangeSelect.value });
          if (res.success) {
            statusDiv.className = 'status-message status-success';
            statusDiv.textContent = '‚úÖ Report saved: ' + res.path;
          } else {
            statusDiv.className = 'status-message status-error';
            statusDiv.textContent = '‚ùå Report failed: ' + res.message;
          }
        } catch (e) {
          statusDiv.className = 'status-message status-error';
          statusDiv.textContent = '‚ùå Report error: ' + e.message;
        } finally {
          generateReportBtn.disabled = false;
          generateReportBtn.textContent = original;
        }
      });
      notifBtn.addEventListener('click', () => {
        notifPanel.style.display = notifPanel.style.display === 'block' ? 'none' : 'block';
      });
      document.addEventListener('click', (e) => {
        if (!notifPanel.contains(e.target) && !notifBtn.contains(e.target)) {
          notifPanel.style.display = 'none';
        }
      });
      clearAlertsBtn.addEventListener('click', () => {
        // Add all currently generated alerts (raw) to dismissed set so they won't reappear
  // Dismiss all existing history
  riskHistory.forEach(a => dismissedAlertKeys.add(riskKey(a)));
  renderNotificationHistory();
        notifPanel.style.display = 'none';
      });

      // Card modals for full graphs
      const modalOverlay = document.createElement('div');
      modalOverlay.className = 'modal-overlay';
      modalOverlay.innerHTML = `
        <div class="modal">
          <div class="modal-header">
            <div class="modal-title" id="modalTitle">Sensor Details</div>
            <button class="close-btn" id="modalClose">‚úñ</button>
          </div>
          <div class="modal-body">
            <canvas id="modalChart"></canvas>
          </div>
        </div>`;
      document.body.appendChild(modalOverlay);

      const modalClose = modalOverlay.querySelector('#modalClose');
      const modalTitle = modalOverlay.querySelector('#modalTitle');
      const modalChartCanvas = modalOverlay.querySelector('#modalChart');
      let modalChartInstance = null;

      function openChartModal(title, baseChart) {
        modalTitle.textContent = title;
        if (modalChartInstance) { modalChartInstance.destroy(); }
        const ctx = modalChartCanvas.getContext('2d');
        // Clone data shallowly for display
        const clonedData = JSON.parse(JSON.stringify(baseChart.data));
        const clonedOptions = JSON.parse(JSON.stringify(baseChart.options));
        clonedOptions.maintainAspectRatio = false;
        modalChartInstance = new Chart(ctx, { type: baseChart.config.type, data: clonedData, options: clonedOptions });
        modalOverlay.style.display = 'flex';
      }

      modalClose.addEventListener('click', () => { modalOverlay.style.display = 'none'; });
      modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) modalOverlay.style.display = 'none'; });

      // Attach click handlers to cards
      document.getElementById('bmp180Card').addEventListener('click', () => openChartModal('BMP180 Environmental Readings', bmp180Chart));
      document.getElementById('mpu6050Card').addEventListener('click', () => openChartModal('MPU6050 IMU Readings', mpu6050Chart));
  document.getElementById('rainCard').addEventListener('click', () => openChartModal('Rainfall Sensor Readings', rainChart));
  document.getElementById('floodsRainCard').addEventListener('click', () => openChartModal('Floods Rain Sensor Readings', floodsRainChart));
      document.getElementById('soilCard').addEventListener('click', () => openChartModal('Soil Moisture Readings', soilChart));
      document.getElementById('tiltCard').addEventListener('click', () => openChartModal('Tilt Sensor Readings', tiltChart));
      document.getElementById('waterLevelCard').addEventListener('click', () => openChartModal('Water Level Readings', waterLevelChart));

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', () => {
        initializeCharts();
        
  // Show initial status
  statusDiv.className = 'status-message';
  statusDiv.innerHTML = 'üí° Welcome to the Disaster Management Control Center';
        
  // Auto-refresh data every 1 second (silent)
  // Keep existing polling as fallback (can be relaxed later)
  setInterval(() => refreshData(true), 5000);
  // Realtime push listener
  if (window.electronAPI && typeof window.electronAPI.onSensorDataUpdate === 'function') {
    window.electronAPI.onSensorDataUpdate((data) => {
      console.log('Realtime sensor update received');
      sensorData = data;
      if (data && data.locations) {
        sensorLocations = { ...sensorLocations, ...data.locations };
      }
      updateSensorDisplays();
      updateCharts();
      checkAlerts();
    });
  }
        
  // Initial data load (silent)
  refreshData(true);
  loadStoredNotifications();
  applyLocationFilter();
      });
    </script>
  </body>
</html>
